;; Used in 'functions' section
(defn multiply-by-ten [n]
  (* 10 n))
(defn square [n] (* n n))

;; Conditionals
(defn explain-defcon-level [exercise-term]
  (case exercise-term
        :fade-out          :you-and-what-army
        :double-take       :call-me-when-its-important
        :round-house       :o-rly
        :fast-pace         :thats-pretty-bad
        :cocked-pistol     :sirens
        :say-what?))

;; Runtime polymorphism
(defn hello
  ([] "Hello World!")
  ([a] (str "Hello, you silly " a "."))
  ([a & more] (str "Hello to this group: "
                   (apply str
                          (interpose ", " (concat (list a) more)))
                   "!")))
(defmulti diet (fn [x] (:eater x)))
(defmethod diet :herbivore [a] :__)
(defmethod diet :carnivore [a] :__)
(defmethod diet :default [a] :__)


(def meditations '(
  ; Equalities
  "We shall contemplate truth by testing reality, via equality"
  (= :__ true)

  "To understand reality, we must compare our expectations against reality"
  (= :__ (+ 1 1))

  "You can test equality of many things"
  (= (+ 3 4) 7 (+ 2 :__))

  "But you may not string yourself along"
  (= :__ (= 2 "2"))

  "Something is not equal to nothing"
  (= :__ (not (= 1 nil)))

  "Strings, and keywords, and symbols: oh my!"
  (= :__ (= "foo" :foo 'foo))

  "Make a keyword with your keyboard"
  (= :foo (keyword :__))

  "Symbolism is all around us"
  (= 'foo (symbol :__))

  "When things cannot be equal, they must be different"
  (not= :fill-in-the-blank :__)

  ;lists
  "Lists can be expressed by function or a quoted form"
  (= '(:__) (list 1 2 3 4 5))

  "They are Clojure seqs (sequences), so they allow access to the first"
  (= :__ (first '(1 2 3 4 5)))

  "As well as the rest"
  (= :__ (rest '(1 2 3 4 5)))

  "Count your blessings"
  (= :__ (count '(dracula dooku chocula)))

  "Before they are gone"
  (= :__ (count '()))

  "The rest, when nothing is left, is empty"
  (= :__ (rest '(100)))

  "Construction by adding an element to the front is easy"
  (= :__ (cons :a '(:b :c :d :e)))

  "Conjoining an element to a list is strikingly similar"
  (= :__ (conj '(:b :c :d :e) :a))

  "You can use a list like a stack to get the first element"
  (= :__ (peek '(:a :b :c :d :e)))

  "Or the others"
  (= :__ (pop '(:a :b :c :d :e)))

  ;; ---
  ;"But watch out if you try to pop nothing"
  ;(= :__ (try
  ;        (pop '())
  ;        (catch IllegalStateException e
  ;          "No dice!")))

  ;"The rest of nothing isn't so strict"
  ;(= :__ (try
  ;        (rest '())
  ;        (catch IllegalStateException e
  ;          "No dice!")))
  ;))

  ;; vectors
   "You can use vectors in clojure as array-like structures"
  (= :__ (count [42]))

  "You can create a vector from a list"
  (= :__ (vec '(1)))

  "Or from some elements"
  (= :__ (vector nil nil))

  "But you can populate it with any number of elements at once"
  (= [1 :__] (vec '(1 2)))

  "Conjoining to a vector is different than to a list"
  (= :__ (conj [111 222] 333))

  "You can get the first element of a vector like so"
  (= :__ (first [:peanut :butter :and :jelly]))

  "And the last in a similar fashion"
  (= :__ (last [:peanut :butter :and :jelly]))

  "Or any index if you wish"
  (= :__ (nth [:peanut :butter :and :jelly] 3))

  "You can also slice a vector"
  (= :__ (subvec [:peanut :butter :and :jelly] 1 3))

  "Equality with collections is in terms of values"
  (= (list 1 2 3) (vector 1 2 :__))

  ;; sets
  #_("You can create a set by converting another collection"
  (= #{3} (set :__))

  "Counting them is like counting other collections"
  (= :__ (count #{1 2 3}))

  "Remember that a set is a *mathematical* set"
  (= :__ (set '(1 1 2 2 3 3 4 4 5 5)))

  "You can ask clojure for the union of two sets"
  (= :__ (clojoure.set/union #{1 2 3 4} #{2 3 5}))

  "And also the intersection"
  (= :__ (clojure.set/intersection #{1 2 3 4} #{2 3 5}))

  "But don't forget about the difference"
  (= :__ (clojure.set/difference #{1 2 3 4 5} #{2 3 5}))
  )

  ;; maps
  "Don't get lost when creating a map"
  (= {:a 1 :b 2} (hash-map :a 1 :__))

  "A value must be supplied for each key"
  (= {:a 1} (hash-map :a :__))

  "The size is the number of entries"
  (= :__ (count {:a 1 :b 2}))

  "You can look up the value for a given key"
  (= :__ (get {:a 1 :b 2} :b))

  "Maps can be used as functions to do lookups"
  (= :__ ({:a 1 :b 2} :a))

  "And so can keywords"
  (= :__ (:a {:a 1 :b 2}))

  "But map keys need not be keywords"
  (= :__ ({2006 "Torino" 2010 "Vancouver" 2014 "Sochi"} 2010))

  "You may not be able to find an entry for a key"
  (= :__ (get {:a 1 :b 2} :c))

  "But you can provide your own default"
  (= :__ (get {:a 1 :b 2} :c :key-not-found))

  "You can find out if a key is present"
  (= :__ (contains? {:a nil :b nil} :b))

  "Or if it is missing"
  (= :__ (contains? {:a nil :b nil} :c))

  "Maps are immutable, but you can create a new and improved version"
  (= {1 "January" 2 :__} (assoc {1 "January" } 2 "February"))

  "You can also create a new version with an entry removed"
  (= :__ (dissoc {1 "January" 2 "February"} 2))

  "Often you will need to get the keys, but the order is undependable"
  (= (list :__ )
     (sort (keys {2010 "Vancouver" 2014 "Sochi" 2006 "Torino"})))

  "You can get the values in a similar way"
  (= (list :__)
     (sort (vals {2006 "Torino" 2010 "Vancouver" 2014 "Sochi"})))

  ;; functions
   "Calling a function is like giving it a hug with parentheses"
  (= :__ (square 9))

  "Functions are usually defined before they are used"
  (= :__ (multiply-by-ten 2))

  "But they can also be defined inline"
  (= :__ ((fn [n] (* 5 n)) 2))

  "Or using an even shorter syntax"
  (= :__ (#(* 15 %) 4))

  "Even anonymous functions may take multiple arguments"
  (= :__ (#(+ %1 %2 %3) 4 5 6))

  "Arguments can also be skipped"
  (= :__ (#(* 15 %2) 1 2))

  "One function can beget another"
  (= 9 (((fn [] :__)) 4 5))

  "Functions can also take other functions as input"
  (= 20 ((fn [f] (f 4 5))
           :__))

  "Higher-order functions take function arguments"
  (= 25 (:__
          (fn [n] (* n n))))

  "But they are often better written using the names of functions"
  (= 25 (:__ square))

  ;; conditionals
  "You will face many decisions"
  (= :__ (if (false? (= 4 5))
          :a
          :b))

  "Some of them leave you no alternative"
  (= :__ (if (> 4 3)
          []))

  "And in such a situation you may have nothing"
  (= :__ (if (nil? 0)
          [:a :b :c]))

  "In others your alternative may be interesting"
  (= :glory (if (not (empty? ()))
              :doom
              :__))

  "You may have a multitude of possible paths"
  (let [x 5]
    (= :your-road (cond (= x :__) :road-not-taken
                        (= x :__) :another-road-not-taken
                        :else :__)))

  "Or your fate may be sealed"
  (= :__ (if-not (zero? :__)
          'doom
          'doom))

  "In case of emergency, sound the alarms"
  (= :sirens
     (explain-defcon-level :__))

  "But admit it when you don't know what to do"
  (= :__
     (explain-defcon-level :yo-mama))

  ;; higher-order functions
  "The map function relates a sequence to another"
  (= [___ :__ :__] (map (fn [x] (* 4 x)) [1 2 3]))

  "You may create that mapping"
  (= [1 4 9 16 25] (map (fn [x] :__) [1 2 3 4 5]))

  "Or use the names of existing functions"
  (= :__ (map nil? [:a :b nil :c :d]))

  "A filter can be strong"
  (= :__ (filter (fn [x] false) '(:anything :goes :here)))

  "Or very weak"
  (= :__ (filter (fn [x] true) '(:anything :goes :here)))

  "Or somewhere in between"
  (= [10 20 30] (filter (fn [x] :__) [10 20 30 40 50 60 70 80]))

  "Maps and filters may be combined"
  (= [10 20 30] (map (fn [x] :__) (filter (fn [x] :__) [1 2 3 4 5 6 7 8])))

  "Reducing can increase the result"
  (= :__ (reduce (fn [a b] (* a b)) [1 2 3 4]))

  "You can start somewhere else"
  (= 2400 (reduce (fn [a b] (* a b)) :__ [1 2 3 4]))

  "Numbers are not the only things one can reduce"
  (= "longest" (reduce (fn [a b]
                         (if (< :__ :__) b a))
                       ["which" "word" "is" "longest"]))

  ;; Run-time polymorphism
  "Some functions can be used in different ways - with no arguments"
  (= :__ (hello))

  "With one argument"
  (= :__ (hello "world"))

  "Or with many arguments"
  (= :__
     (hello "Peter" "Paul" "Mary"))

  "Multimethods allow more complex dispatching"
  (= "Bambi eats veggies."
     (diet {:species "deer" :name "Bambi" :age 1 :eater :herbivore}))

  "Different methods are used depending on the dispatch function result"
  (= "Simba eats animals."
     (diet {:species "lion" :name "Simba" :age 1 :eater :carnivore}))

  "You may use a default method when no others match"
  (= "I don't know what Rich Hickey eats."
     (diet {:name "Rich Hickey"}))

  ;; lazy sequences
  "There are many ways to generate a sequence"
  (= :__ (range 1 5))

  "The range starts at the beginning by default"
  (= :__ (range 5))

  "Only take what you need when the sequence is large"
  (= [0 1 2 3 4 5 6 7 8 9]
     (take :__ (range 100)))

  "Or limit results by dropping what you don't need"
  (= [95 96 97 98 99]
     (drop :__ (range 100)))

  "Iteration provides an infinite lazy sequence"
  (= :__ (take 20 (iterate inc 0)))

  "Repetition is key"
  (= [:a :a :a :a :a :a :a :a :a :a ]
     (repeat 10 :__))

  "Iteration can be used for repetition"
  (= (repeat 100 :foo)
     (take 100 (iterate :__ :foo)))
))